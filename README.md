# Portfolio of Val Joshua G. Garcia Section EL
dismathportfolio-joshuagarcia2875 created by Classroom for GitHub

#Week 1 (Orientation and Discussion of Syllabus)
- I learned the topics to be discussed in this course, outputs and requirements needed to be accomplished for this course
- I learned the use of truth table for proving
- I learned to use logical connectives 
- I learned to propositional variables to represent propositions

#Week 2 
- I learned about different logical equivalances and how it can be used for proofs.
- I learned about quantifiers and the difference between existential quantifier and universal quantifier.
- I learned about rules of inferences and how it can be used in arguments.

#Week 3
- I learned about the different rules of inferences such as modus ponens, modus tollens, hypothetical syllogism and disjunctive syllogism.
- I learned to determine whether a statement is a fallacy or not using truth tables and the rules of inferences.
- I learned to use the rules of inferences to prove the validity of an argument.
- I also learned to use these rules of inferences to build arguments.

#Week 4 
- I learned different ways to prove an argument through different ways like direct proof,proof by contraposition, trivial proof and vacuous proof.
- I learned the steps on how to perform these proofs and use it in a problem.
- Our class answered different examples to be able to master using these methods of proof.

#Week 5
- I learned about proof by equivalence
- Using proof by equivalence is a bit more lengthy than the other proofs but it is more interesting and exciting.
- Our class answered different examples where we can apply proof by equivalance
- I learned about mathematical induction and the process of how it is done
- Mathematical induction involves a basis and an inductive step(direct proof)
- I learned about Recursive/Inductive Defintion and Recursive Algorithm
- Our class answered various exercises about Recursive Definition and Recursive Algorithm

#Week 6
- Our class continued the discussion about Recursive Algorithm
- We answered additional exercises about Recursive Algorithm
- I learned about Program Correctness and its steps
- The first step is about partial correctness.
- First, I need to prove the correct answer is obtained if the program terminates (PARTIAL CORRECTNESS)
- The second step is to show that the program always terminates.
- I also learned about the Inital Assertion which gives that the input values must have and the Final Assertion which are output values.
- I also learned about the Hoare Triple: p{S}q
- Our class answered exercises about Program Correctness
- I learned about Zeno's Paradox and the Power Series.
- Our class answered different exercises to further improve our understanding about Zeno's Paradox and Power Series
- I discovered about the Set Theory and what a Power Set is and what Cardinality means.

#Week 7
- I learned about subset and superset
- Cardinality is a measure of elements of the sets
- Functions were discussed.
- I learned about the One-to-One Function or Injective, Onto Function or Surjective and lastly, the Bijective
- I also learned the one-to-many which is not function

#Week 8
- Time to do our Project 0-0 or the Hello World Application using MIT App Inventor
- This is an individual project

#Week 9
- I learned about algorithm which refers to sets of rules to be followed by a computer
- A pseudocode is a high-level description of an algorithm that uses structural convention of a programming language.
- I learned about precondition which are input values and postcondition which are output values

#Week 10
- I learned about linear search and binary search 
- Linear search -> in this kind of search, it searches individually or one by one
- Binary search -> in this kind, the list is divided into two and comparison is being done. It will stop when the first 
and last element is common.
- We discussed in class the different kinds of sorting in increasing order:Bubble Sort, Insertion Sort and Greedy Algorithm
- We did exercises to test our understanding of the pseudocode and analyse the function or purpose of each block of code in the pseudocode.
- Sorting is putting elements into a list in which the elements are in increasing order
- Bubble sort puts a list into increasing order by successively comparing adjacent elements. The two adjacent element interchange with each other if they are in the wrong order.
- In bubble sort, we intechange a larger element with the smaller element adjacent to it. The bubble sorting starts with the first element up to the last element for a full pass. The sorting repeats until the list is completely sorted.
- A good analogy or visualization for the bubble sort is imagining small-valued elements "bubble" or goes to the top as the interchanging happens with the larger elements, while the larger element goes down to the bottom.
-Bubble sort algorihm uses "for" loop
- In insertion sort, it starts with the second element. Insertion sort compares the second element with the first element and it inserts the second element before the first element if it is not greater than the first element. If the second element is greater than the first element, it is placed after the first element. 
- The insertion sort has a outer "for" loop, inner "while" loop and inner "for" loop
- The outer "for" loop makes it move from element to element
- The inner "while" loop serves as the comparison 
- The inner "for" loop serves to sort
- In greedy algorithm, this algorithm help us decide what is the "best" choice at each step.
- An example for greedy algorithm is the greedy change-making algorithm which produces change using the fewest number of coins possible.

#Week 11
- Big O means upper bound function
- Big Omega means lower bound function
- Big Theta means both Big O and Big Omega thefore both upper bound and lower bound
- I learned about Time Complexity of different algorithms and Worst-case complexity 
- Worst case performance of an algorithm means the largest number of operations needed to the problem given using
 the specified algorithm
- I also learned about Caesar Cipher which is a really fun and interesting topic

 #Week 12
- Our main topic for this week is Graph Theory
- A graph has vertices and edges
- The degree of a vertex in an undirected graph is the number of edges incident with it. Take note that, a loop at vertex counts twice to the degree of that vertex
- I learned about the handshaking theorem
- Formula : 2e = Summation [(degree)(vertices)]
- A graph is connected if there is no isolated node/s.
- To be a Euler circuit, it should cover all "bridges" and return to starting point, all nodes should have even degrees
- To be a Euler path, it should cover all "bridges" but not return to starting point, thefore starting vertex is not equal to the final vertex.
- To be a Hamilton circuit, it should pass through all nodes and return to starting node.
- To be a Hamilton path, it should pass through all nodes but not return to starting node.
- A pendant is a node with one degree
- If a graph has a pendant, there will no hamilton circuit.
- If there are 3 pendants in a graph, there will no hamilton circuit and no hamilton path.
- I learned how to determine a graph by its adjacency matrix and vice versa.
- For two graphs to be isomorphic: 
- 1.) Number of nodes should be equal
- 2.) Number of connection should be equal
- 3.) One-to-one correspodence
- 4.) Onto function
- Planar graphs are graphs that can be drawn in the plane without edges having to cross.
- I learned about the Euler's Formula
- Formula: r = e-v+2  where e represents edges, v represents vertices and r represents number of regions
- Two graphs are homeomorphic if they can be obtained from the same graph by a sequence of elementary subdivisions.

#Week 13
- We started this week discussing about Graph Coloring
- No two adjacent vertices should have the same assigned color
- The chromatic number of a graph is the least number of colors required to color a graph
- Its worst-time complexity is exponential
- There are some useful rules to remember such as: The chromatic number of a planar is equal to or less than four while non-planar graphs could exceed four.
- If odd number cycle like C_5, the chromatic number is odd
- If even number cycle like C_100, the chromatic number is even
- We also discussed about trees which is a connected undirected graph with no simple circuits.
- It looks like a hierarchical tree structure with many nodes that are connected to each other
- We did exercises to determine which of the graph is a Tree
- Theorem discussed: An undirected graph is tree if there is a unique simple path between any two of its vertices. 
- A rooted tree is a type of tree in which one node is chosen to be as the root and every edge is directed away from the root.
- We did an exercise to test our understanding of rooted tree.
- A m-ary tree is a rooted tree which every internal vertex has no more than "m" children.
- A rooted tree which the children of each internal node is order is called an ORDERED ROOTED TREE
- We discussed the different properties of trees and answered an exercise.
- We discussed about Language and Grammars
- English language can sometimes be vague and some English words may be confusing because one word could have multiple meanings
- A formal language is specified by a well-defined set of rules of syntax
- In the discussion of programming, syntax or the grammar is very vital.
- A language is a set of strings.
- An automata is a mathemical model of computing device.
- An automaton is an idealized mathematical computing machine.
- A finite automaton is a simple type of mathematical machine for determining whether a string is contained within some language.
- Lexical analysis is the process of analyzing a stream of individual characters into a sequence of lexical tokens.
- Finite-state machine: M = {S, I, O, f, g, s(0)} where S corresponds to states, I corresponds to input, O corresponds to output, f corresponds to function, g corresponds to function output and s(0) means initial state.

#READING ASSIGNMENT (topics are included in the Final Examination)
- Tree traversal is a form of graph of tree traversal and refers to the process of visiting each node in a tree data structure exactly once.
- Binary traversal methods: preorder, inorder, postorder
- A simple graph with a spanning tree must be connected, because there is a path in the spanning tree between any two vertices.
- Let G corresponds to a simple graph. A spanning tree of G is a subgraph of G that is a tree containing every vertex of G.
- A minimum spanning tree is a spanning tree that has the smallest possible sum of weights of its edges.
- Relations is a relationship of elements between two sets.
- A binary relation from a set A to a set B is a subset of A x B
- Assume A is a set, and R be a binary relation on A;
- R is reflexive if 
- ∀x[(x ∈ A) → ((x, x) ∈ R)]
- R is symmetric if
- ∀x∀y[((x, y) ∈ R) → ((y, x) ∈ R)]
- R is antisymmetric if
- ∀x∀y[([(x, y) ∈ R] ∧ [(y, x) ∈ R]) → (x = y)]
- R is assymetric if 
- ∀x∀y[((x, y) ∈ R) → ((y, x) 6∈ R)].
- R is transitive if
- ∀x∀y∀z[([(x, y) ∈ R] ∧ [(y, z) ∈ R]) → ((x, z) ∈ R)]
- An equivalence relation refers to a relation that is reflexive, symmetric and transitive.
- An n-ary relation refers to the relationship of elements from two or more sets; A1 x A2 x An, where A-domains and n-degree.
- Composite (S o R)
- (a,b) and (b,c) such that (a,c), from sets A, B, C.
- A relation R on a set S is called a partial ordering or partial order if it is reflexive, antisymmetric, and transitive.
- A set S together with a partial ordering R is called a partially ordered
- set, or poset, and is denoted by (S, R).
- Members of S are called elements of the poset.
- Lexicographic order -> it is based in the ordering of the letters in the alphabet.
- Lexicographic order is sometimes called dictionary order.
- Lattices is a poset where every pair of elements if there is a unique least upper bound and a unique greatest lowest bound.


